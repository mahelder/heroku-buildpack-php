#!/usr/bin/env bash

# bin/compile <build-dir> <cache-dir> <env-dir>

# fail hard
set -o pipefail
# fail harder
set -eu
# move hidden files too, just in case
shopt -s dotglob

STACK=${STACK:-heroku-18} # Anvil has none
build_dir=$1
cache_dir=$2/php
mkdir -p "$cache_dir"
env_dir=${3:-} # Anvil has none
bp_dir=$(cd $(dirname $0); cd ..; pwd)

export BPLOG_PREFIX="buildpack.php"
export BUILDPACK_LOG_FILE=${BUILDPACK_LOG_FILE:-/dev/null}

# convenience functions
source $bp_dir/bin/util/common.sh

# use err_trap from common.sh on error
# we do not 'set -o errtrace', because that would cause subshell failures to fire the trap twice, e.g. with someval=$(func_that_fails)
trap 'err_trap' ERR

# stdlib
# download to a file first, as the function restarts the entire download on code 18 connection reset (not all servers support -C)
curl_retry_on_18 --fail --silent --location -o $bp_dir/bin/util/stdlib.sh https://lang-common.s3.amazonaws.com/buildpack-stdlib/v8/stdlib.sh || {
	error <<-EOF
		Failed to download standard library for bootstrapping!
		
		This is most likely a temporary internal error. If the problem
		persists, make sure that you are not running a custom or forked
		version of the Heroku PHP buildpack which may need updating.
	EOF
}
source $bp_dir/bin/util/stdlib.sh
rm $bp_dir/bin/util/stdlib.sh

# failure counting
source $bp_dir/bin/util/failures.sh

# for extensions that need special treatment
source $bp_dir/bin/util/newrelic.sh
source $bp_dir/bin/util/blackfire.sh

# if this is set it prevents Git clones (e.g. for Composer installs from source) during the build in some circumstances, and it is set in SSH Git deploys to Heroku
unset GIT_DIR

cd $build_dir

export_env_dir "$env_dir" '^COMPOSER$'
if [[ -n ${COMPOSER:-} ]]; then
	status "Using '$COMPOSER' (from "'$COMPOSER env var) for installation.'
else
	export COMPOSER="composer.json"
fi
export COMPOSER_LOCK=$(basename "$COMPOSER" ".json")".lock" # replace .json with .lock if it exists, append .lock otherwise

# we're using this error message in two places
composer_lock_parse_error=$(
	cat <<-EOF
		Failed to parse '$COMPOSER_LOCK'!

		There was an error parsing '$COMPOSER_LOCK'; it must be a valid
		file generated by Composer and be in an up-to-date state.

		Look above for any parse errors and address them if necessary.

		You most likely created or edited the file by hand, or a merge
		conflict was not resolved properly, resulting in a syntax error
		in the file. Refer to the docs for information on re-generating
		the lock file: https://getcomposer.org/doc/01-basic-usage.md

		Please perform the following steps locally on your computer to
		resolve this issue before attempting another deploy:
		1) Run 'composer update' to re-generate the lock file
		2) stage the lock file changes using 'git add $COMPOSER_LOCK'
		3) commit the change using 'git commit'

		You can run 'composer validate' locally on your computer for
		further diagnosis. Remember to also always keep your lock file
		up to date with any changes according to the instructions at
		https://getcomposer.org/doc/01-basic-usage.md

		Please remember to always keep your '$COMPOSER_LOCK' updated in
		lockstep with '$COMPOSER' to avoid common problems related
		to dependencies during collaboration and deployment.
	EOF
)

# a bunch of sanity checks first
if [[ -s "$COMPOSER" ]]; then
	cat "$COMPOSER" | python -mjson.tool &> /dev/null || {
		mcount "failures.composer_json.lint"
		error <<-EOF
			Basic validation for '$COMPOSER' failed!
			
			It must be a valid JSON document compatible with Composer.
			
			You most likely created or edited the file by hand, and it now
			contains a syntax error. Please refer to the documentation at
			https://getcomposer.org/doc/ for information on the format.
			
			You can run 'composer validate' locally on your computer for
			further diagnosis. Remember to also always keep your lock file
			up to date with any changes according to the instructions at
			https://getcomposer.org/doc/01-basic-usage.md
		EOF
	}
	if [[ ! -f "$COMPOSER_LOCK" ]]; then
		cat "$COMPOSER" | python -c 'import sys, json; sys.exit(bool(json.load(sys.stdin).get("require", {})))' 2> /dev/null || {
			mcount "failures.composer_lock.missing"
			error <<-EOF
				No '$COMPOSER_LOCK' found!
				
				A '$COMPOSER_LOCK' file was not found in your project, but there
				is a '$COMPOSER' file with dependencies inside 'require'.
				
				The lock file is required in order to guarantee reliable and
				reproducible installation of dependencies across platforms and
				deploys. You must follow the Composer best practice of having
				your lock file under version control in order to deploy. The
				lock file must not be in your '.gitignore'.
				
				Please perform the following steps locally on your computer to
				resolve this issue before attempting another deploy:
				1) remove '$COMPOSER_LOCK' from file '.gitignore', if present
				2) if no '$COMPOSER_LOCK' exists, run 'composer update'
				3) stage the lock file changes using 'git add $COMPOSER_LOCK'
				4) if you edited '.gitignore', also run 'git add .gitignore'
				5) commit the change using 'git commit'
				
				Please remember to always keep your '$COMPOSER_LOCK' updated in
				lockstep with '$COMPOSER' to avoid common problems related
				to dependencies during collaboration and deployment.
				
				Please refer to the Composer documentation for further details:
				https://getcomposer.org/doc/
				https://getcomposer.org/doc/01-basic-usage.md
			EOF
		}
	else
		cat "$COMPOSER_LOCK" | python -mjson.tool &> /dev/null || {
			mcount "failures.composer_lock.lint"
			error "$composer_lock_parse_error"
		}
	fi
else
	if [[ ! -f "$COMPOSER" ]]; then
		mcount "warnings.composer_json.missing"
		warning <<-EOF
			No '$COMPOSER' found!
			
			Your project only contains an 'index.php', no '$COMPOSER'.
			
			Using 'index.php' to declare app type as PHP is deprecated and
			may lead to unexpected behavior.
			
			Please consider updating your codebase to utilize Composer and
			modern dependency management in order to benefit from the latest
			PHP runtimes and improved application performance, as well as
			control over the PHP versions and extensions available.
			
			For an introduction to dependency management with Composer and
			how to get the most out of PHP on Heroku, refer to the docs at
			https://getcomposer.org/doc/00-intro.md and
			https://devcenter.heroku.com/articles/getting-started-with-php
		EOF
	else
		mcount "warnings.composer_json.empty"
		notice <<-EOF
			Your '$COMPOSER' is completely empty!
			
			A completely empty file is not a valid JSON document.
			
			Heroku automatically corrected this problem, but it is strongly
			recommended you change the contents to at least '{}'.
			
			For documentation on Composer and dependency management, check
			out the introduction at https://getcomposer.org/doc/00-intro.md
		EOF
	fi
	echo "{}" > $COMPOSER
fi

# PHP expects to be installed in /app/.heroku/php because of compiled paths, let's set that up!
mkdir -p /app/.heroku
# all system packages live in there
mkdir -p $build_dir/.heroku/php
# set up Composer
export COMPOSER_HOME=$cache_dir/.composer
mkdir -p $COMPOSER_HOME

# if the build dir is not "/app", we symlink in the .heroku/php subdir (and only that, to avoid problems with other buildpacks) so that PHP correctly finds its INI files etc
[[ $build_dir == '/app' ]] || ln -s $build_dir/.heroku/php /app/.heroku/php

status "Bootstrapping..."

# minimal PHP needed for installs, and make "composer" invocations use that for now
mkdir -p $build_dir/.heroku/php-min
ln -s $build_dir/.heroku/php-min /app/.heroku/php-min

tar xzf $bp_dir/bin/libs/php-min.tar.gz -C $build_dir/.heroku/php-min
tar xzf $bp_dir/bin/libs/composer.tar.gz -C $build_dir/.heroku/php bin/composer

mv $build_dir/.heroku/php/bin/composer{,1} # we will need this at the end even if user installs happen with Composer 2

# this alias is just for now while we install platform packages
composer() {
	/app/.heroku/php-min/bin/php /app/.heroku/php/bin/composer1 "$@"
}
export -f composer

# we use --no-plugins just in case the vendor dir is there, see e.g. https://github.com/Ocramius/PackageVersions/issues/64
composer_vendordir=$(composer config --no-plugins vendor-dir)
composer_bindir=$(composer config --no-plugins bin-dir)

mkdir -p $build_dir/.profile.d

# we perform this check early so people with stale lock files are reminded why if their lock file errors in the next step
composer_lock_outdated=false
composer validate --no-plugins --no-check-publish --no-check-all --quiet "$COMPOSER" 2>/dev/null || {
	mcount "warnings.composer_lock.outdated"
	composer_lock_outdated=true
	warning <<-EOF
		Your '$COMPOSER_LOCK' is out of date!
		
		The '$COMPOSER_LOCK' file in your project is not up to date with
		the main '$COMPOSER' file. This may result in installation
		of incorrect packages or package versions.
		
		The lock file is required in order to guarantee reliable and
		reproducible installation of dependencies across systems and
		deploys. It must always be kept in sync with '$COMPOSER'.
		
		Whenever you change '$COMPOSER', ensure that you perform
		the following steps locally on your computer:
		1) run 'composer update'
		2) add all changes using 'git add $COMPOSER $COMPOSER_LOCK'
		3) commit using 'git commit'
		
		Ensure that you updated the lock file correctly, and that you
		ran 'git add' on both files, before deploying again.
		
		Please remember to always keep your '$COMPOSER_LOCK' updated in
		lockstep with '$COMPOSER' to avoid common problems related
		to dependencies during collaboration and deployment.
		
		Please refer to the Composer documentation for further details:
		https://getcomposer.org/doc/
		https://getcomposer.org/doc/01-basic-usage.md
	EOF
}

# if prefer-stable is false and minimum-stability is not stable, warn about potential unstable platform installs
[[ ! -f "$COMPOSER_LOCK" ]] || minimum_stability=$(cat "$COMPOSER_LOCK" | python -c 'import sys, json; l = json.load(sys.stdin); print(l.get("minimum-stability")); sys.exit(l.get("minimum-stability", "stable") != "stable" and l.get("prefer-stable", False) == False);' 2> /dev/null) || {
	possible_stabilities="dev, alpha, beta, or RC"
	case $minimum_stability in
		alpha)
			possible_stabilities="alpha, beta, or RC"
			;;
		beta)
			possible_stabilities="beta or RC"
			;;
		[rR][cC])
			possible_stabilities="release candidate"
			;;
	esac
	mcount "warnings.composer_lock.minimum_stability"
	warning <<-EOF
		Non-stable 'minimum-stability'!
	
		Your '$COMPOSER' contains a 'minimum-stability' setting of
		'$minimum_stability', and the 'prefer-stable' setting is not enabled.
		
		This combination of options may negatively impact the stability
		of your app and result in crashes as it permits installation of
		$possible_stabilities versions of PHP runtimes and extensions.
		
		If possible, you should always use explicit stability flags on
		only those dependencies that you want unstable versions of, and
		leave 'minimum-stability' at its default 'stable' setting.
		
		If you really need a global 'minimum-stability' setting lower
		than 'stable', it is strongly recommended that you enable the
		'prefer-stable' setting in '$COMPOSER'.
		
		For more information, refer to the following documentation:
		https://getcomposer.org/doc/articles/versions.md
		https://getcomposer.org/doc/04-schema.md#package-links
		https://getcomposer.org/doc/04-schema.md#minimum-stability
		https://getcomposer.org/doc/04-schema.md#prefer-stable
	EOF
}

status "Installing platform packages..."

HEROKU_PHP_DEFAULT_RUNTIME_VERSION="^5.6.0"
export HEROKU_PHP_DEFAULT_RUNTIME_VERSION

composer install

# # reset $COMPOSER for the platform install step
# COMPOSER_bak="$COMPOSER"
# export COMPOSER=composer.json


# # done with platform installs; restore COMPOSER from previous value
# export COMPOSER="$COMPOSER_bak"
# unset COMPOSER_bak

# # clean up
# rm -rf /app/.heroku/php-min $build_dir/.heroku/php-min
# # unset composer function that used php-min for invocation
# unset -f composer

# # export our "do not auto.start APM extensions" magic INI directory to PHP_INI_SCAN_DIR for ourself and for later buildpacks (but not for runtime)

# status "Installing dependencies..."


# status "Preparing runtime environment..."

# # install this buildpack like a composer package
# # it will contain the apache/nginx/php configs and the boot script
# # TODO: warn if require-dev has the package using a different branch
# shopt -u dotglob # we don't want .git, .gitignore et al
# # figure out the package dir name to write to and copy to it
# hbpdir="$composer_vendordir/$(cat $bp_dir/composer.json | python -c 'import sys, json; print(json.load(sys.stdin)["name"])')"
# mkdir -p "$build_dir/$hbpdir"
# cp -r "$bp_dir"/* "$build_dir/$hbpdir/"
# # make bin dir, just in case
# mkdir -p "$build_dir/$composer_bindir"
# # figure out shortest relative path from vendor/heroku/heroku-buildpack-php to vendor/bin (or whatever the bin dir is)
# relbin=$(python -c "import os.path; print(os.path.relpath('$hbpdir', '$composer_bindir'))")
# # collect bin names from composer.json
# relbins=$(cat $bp_dir/composer.json | python -c 'from __future__ import print_function; import sys, json; { print(sys.argv[1]+"/"+bin) for bin in json.load(sys.stdin)["bin"] }' $relbin)
# # link to bins
# cd $build_dir/$composer_bindir
# ln -fs $relbins .
# cd $build_dir

# if [[ ! -f "Procfile" ]]; then
# 	echo "web: heroku-php-apache2" > Procfile
# 	notice_inline "No Procfile, using 'web: heroku-php-apache2'."
# fi

# # write empty WEB_CONCURRENCY.sh to overwrite the defaults logic from a prior buildpack, e.g. Node (all buildpacks use the same filename to allow this)
# > $build_dir/.profile.d/WEB_CONCURRENCY.sh

# # reset COMPOSER for the platform install step
# COMPOSER_bak="$COMPOSER"
# export COMPOSER=composer.json

# # done with platform installs; restore COMPOSER from previous value
# export COMPOSER="$COMPOSER_bak"
# unset COMPOSER_bak
# # and remove the composer1 program we needed for platform installs
# rm $build_dir/.heroku/php/bin/composer1
